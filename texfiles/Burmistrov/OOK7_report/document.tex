\documentclass[cp1251,usehyperref,14pt]{G7-32}

\usepackage[T2A]{fontenc}
\usepackage[cp1251]{inputenc}
\usepackage[russian]{babel} 
\usepackage {listings}
\usepackage{graphicx}
\usepackage{lscape}
\usepackage{rotating}
\usepackage{indentfirst}
\usepackage{float}
\usepackage{morefloats}
\usepackage{longtable}
\usepackage{setspace}
\usepackage{verbatim}
\usepackage{hyperref}
\usepackage{textcomp}
\usepackage{setspace}

\onehalfspacing

\usepackage{indentfirst}     
\usepackage{longtable}
\usepackage{array}
\usepackage{multirow}

\DeclareCaptionLabelSeparator{dot}{. }
\captionsetup{justification=centering,labelsep=dot}  

\geometry{left=2cm}
\geometry{right=1.5cm}
\geometry{top=2cm}
\geometry{bottom=2cm}

\TableInChapter
\PicInChapter

\gdef\theequation{\arabic{chapter}.\arabic{equation}}

% Определяем заголовки для титульной страницы

\NirOrgLongName{\textbf{Федеральное государственное автономное образовательное учреждение \\
высшего профессионального образования \\
<<Уральский федеральный университет \\
имени первого Президента России Б.Н.Ельцина>>\\
\ \\
Уральский региональный центр \\
образования и разработок
}}

\NirBoss{Директор Уральского регионального центра образования и разработок кандидат физико-математических наук,
доцент}{Асанов М.О.}

\NirManager{аспирант УрФУ}{Бурмистров И.С.}

\NirYear{2011}

\NirTown{г. Екатеринбург,}

\NirUdk{УДК }
\NirGosNo{Код ГРНТИ}
\NirStage{вид отчета:}{}{итоговый}

\bibliographystyle{unsrt}

%%%%%%%<------------- НАЧАЛО ДОКУМЕНТА

\begin{document}

\usefont{T2A}{ftm}{m}{} %%% Использование шрифтов Т2 для возможности скопировать текст из PDF-файлов.

\frontmatter %%% <-- это выключает нумерацию ВСЕГО; здесь начинаются ненумерованные главы типа Исполнители, Обозначения и прочее

\NirTitle{по проекту \No \  ООК 7 \quad <<Создание средств для упрощения реализации трудоемких алгоритмов на языке Java и мониторинга их состояния>> \\ 
в рамках Открытого окружного конкурса студенческих инициативных научных \\ 
исследований в области информатики и информационных технологий}


\Executors %% Список исполнителей здесь

\begin{longtable}{p{0.5\linewidth}p{0.2\linewidth}p{0.35\linewidth}}

Научный руководитель, 	& \rule{1\linewidth}{0.1pt} & \emph{Бурмистров И.С.}\\

\emph{аспирант УрФУ}	& \qquad \footnotesize{подпись, дата} &\footnotesize{(раздел(ы)\underline{~~~~~~~~~})} \\

& & \\

Исполнители  &		&	\\

\emph{студентка КН-302, института математики} & \rule{1\linewidth}{0.1pt}& \emph{Техажева С.А.} \\

\emph{и компьютерных наук УрФУ}& \qquad \footnotesize{подпись, дата} & \footnotesize{(раздел(ы)\underline{~~~~~~~~~})}\\

\emph{студент КН-302, института математики} & \rule{1\linewidth}{0.1pt}& \emph{Мухаметьянов Д.И.}\\

\emph{и компьютерных наук УрФУ}& \qquad \footnotesize{подпись, дата}	& \footnotesize{(раздел(ы)\underline{~~~~~~~~~})}\\

\emph{студент КН-401, института математики} & \rule{1\linewidth}{0.1pt}& \emph{Плинер Ю.А.}\\

\emph{и компьютерных наук УрФУ}& \qquad \footnotesize{подпись, дата}	& \footnotesize{(раздел(ы)\underline{~~~~~~~~~})}\\

& & \\

Нормоконтролер  &  \rule{1\linewidth}{0.1pt} &  \\

& \qquad \footnotesize{подпись, дата}	&  \\

\end{longtable}

\Referat 

Объектом исследования является автоматизированная система по анализу работы трудоемких алгоритмов.

Цель работы --- разработка системы, которая позволила бы удобным способом собирать статистику работы 
исследуемых алгоритмов и в визуальном виде представлять эту статистику.

В рамках научно-исследовательской работы была спроектирвоана и реализована  система по управлению исследованиями,
включающая в себя базу данных текстов~-- возможных входных данных для алгоритмов, сервис по запуску алгоритмов,
веб-сервис для сбора статистики и визуализации результатов. Также была разработана концепция автоматизированного
DI-контейнера, внедрение которого позволит существенным образом сократить и упростить конфигурирование 
любых приложений, написанных на языке Java, в том числе исследуемые алгоритмы, а также саму систему по управлению исследованиями.

Система по управлению исследованиями была реализована на языке Java SE. 

Внедрение реализованной системы позволило одной исследовательской группе собрать в одном месте базу входных данных
для исследуемых алгоритмов, результаты работы этих алгоитмов, а также автоматизировать процесс сбора статистики и визуализации
результатов.

Степень внедрения системы по управлению исследованиями --- процесс сбора статистики работы алгоритмов полностью переведен на реализованную систему.
Веб-сервис для демонстрации текущего состояния исследований доступен по адресу \url{http://overclocking.usu.edu.ru}.

Степень реализации автоматизированного DI-контейнера --- реализован прототип контейнера, полностью работоспособный, но 
ограниченный по функциональности.

Степень внедрения автоматизированного DI-контейнера --- в код системы по управлению исследованиями внедрено использование
DI-контейнера, который впоследствии практически незаметным образом будет заменен на автоматизированный DI-контейнер, когда
тот будет полностью реализован.

Весь исходный код доступен по адресу \url{http://overclocking.googlecode.com/svn/webService/trunk}.

\tableofcontents

%\NormRefs % Нормативные ссылки 

%\Defines % Необходимые определения 

%\Abbreviations %% Список обозначений и сокращений в тексте

%\begin{abbreviation}

%\item[ТНГ] Торсионный нано генератор -- образец лженаучного волюнтаризма.

%\end{abbreviation}


\Introduction

Исследования трудоемких алгоритмов, работающих длительное время~-- достаточно тяжелая задача.
Если алгоритм выполняется в течение нескольких часов или дней, то необходимо учитывать многие внешние факторы, например:
неожиданное выключение света, отказ жесткого диска, параллельно выполняющиеся программы. Кроме того, необходима качественная система
логгирования, чтобы в случае ошибки ее причину можно было бы понять по логам. Это означает, что к исследовательским задачам
необходимо подходить как к задачам промышленной разработки ПО и использовать современные подходы этой области, например:
\begin{itemize}
\item покрывать код большим количеством автоматизированных тестов, чтобы минимизировать вероятность ошибки
\item разрабатывать качественную архитектуру исследовательского проекта, чтобы максимально быстро вносить в него необходимые изменения
\item использовать системы контроля версий, чтобы иметь возможность следить за историей изменения той или иной части проекта\\
\end{itemize}


Когда исследования достаточно обширные и требуют запуска алгоритма в различных условиях с разными параметрами, то появляются дополнительные трудности:
\begin{itemize}
\item алгоритм может запускаться на разных компьютерах, но должен использовать все время одни и те же входные данные
\item все результаты работы необходимо собирать в одно место для анализа
\item большое количество настроек вынуждает использовать конфигурационные файлы, за корректным заполнением которых необходимо следить\\
\end{itemize}


Если подходить к решению всех этих трудностей с должным уровнем внимания и качества, то может оказаться, что основное время при исследовании
тратится на вещи, напрямую к исследованию не относящиеся: запуск алгоритмов с различными настройками, сбор результатов с большого количества компьютеров,
отслеживание состояния всех запущенных программ.

Результаты НИР помогли одной исследовательской группе сконцентрироваться на непосредственной реализации алгоритмов и минимизировали накладные расходы
на сбор и анализ результатов.
В частности, в рамках НИР была проделана следующая работа:
\begin{enumerate}
\begin{item}
	реализована система для управления исследованиями, состоящая из нескольких частей:
	\begin{itemize}
		\item веб-сервис для отображения текущего состояния исследований и построения графиков по их результатам
		\item единое хранилище входных данных алгоритмов и их результатов
		\item сервисы для запуска алгоритмов
	\end{itemize}	
\end{item}
\item исследована возможность применения IDE-контейнера при реализации трудоемких алгоритмов и требования к его интерфейсу
\item исследованы существующие реализации IDE-контейнеров
\item разработан интерфейс автоматизированного IDE-контейнера, удовлетворяющего всем требованиям\\
\end{enumerate}

В первой части отчета будут описаны результаты разработки системы для управления исследованиями.
Вторая часть отчета посвящена обзору существующих IDE-контейнеров и обоснованию выбора автоматизированного IDE-контейнера
для внедрения в код веб-сервиса и исследуемых алгоритмов.

Весь исходный код системы по управлению исследованиями, а также DI-контейнера, доступен по адресу 
\url{http://overclocking.googlecode.com/svn/webService/trunk}.

\mainmatter %% это включает нумерацию глав и секций в документе ниже

\chapter{Система для управления исследованиями}

При разработке архитектуры системы необходимо было учитывать следующие требования:

\begin{enumerate}
\begin{item}
система должна обладать свойством масштабируемости, то есть увеличивать производительность при добавлении новых мощностей.
Это необходимо в силу трудоемкости исследуемых алгоритмов. Важно уметь проводить исследования параллельно на нескольких
компьютерах.
\end{item}
\begin{item}
алгоритм должен иметь возможность сохранить любой промежуточный результат, чтобы впоследствии возобновить работу 
с некоторого состояния без перезапуска всего алгоритма. Это позволит каждый алгоритм декомпозировать на небольшие составные части,
тем самым защищаясь от внешних факторов, таких как выключение света или крах оборудования.
\end{item}
\begin{item}
входными данными для алгоритмов являются тексты достаточно большого размера (до нескольких гигабайт).\\
\end{item}
\end{enumerate}

Система состоит из 7 основных частей:
\begin{enumerate}
\item NoSQL-база данных для хранения входных данных алгоритмов, а также результатов их работы
\item сервис импорта входных данных для алгоритмов
\item сервис запуска алгоритмов
\item SQL-база данных для хранения статистической информации по результатам запуска алгоритмов
\item сервис импорта статистической информации в SQL-базу
\item сервис экспорта статистической информации из NoSQL-базы данных в SQL-базу
\item веб-сервис для отображения текущего состояния системы, а также построяния графиков по результатам работы
\end{enumerate}

Остановимся на каждой из частей подробнее.

\newpage
\section{NoSQL-база данных Cassandra}

В качестве NoSQL-базы данных была выбрана широко известная база данных Cassandra,
поскольку она обладает следующими характеристиками:
\begin{enumerate}
\begin{item}
распределенность. Базу данных можно развернуть на нескольких физических компьютерах.
При этом все данные могут храниться в нескольких копиях для защиты от их непредвиденной потери.
\end{item}
\begin{item}
масштабируемость. Количество компьютеров, на которых развернута база данных, можно легко увеличивать.
\end{item}
\begin{item}
устойчивость к сбоям. С базой данных по-прежнему можно работать, даже если некоторые ее узлы стали по какой-то причине 
недоступными.
\end{item}
\begin{item}
простота использования. Cassandra проста как для администрирования, так и для использования в реальных приложениях, поскольку
имеет уже написанных клиентов для большинства языков программирования.\\
\end{item}
\end{enumerate}

Перед объяснением того, каким образом было организовано хранение данных в Cassandra, кратко объясним основные принципы работы этой
базы данных.

\subsection{Введение в модель данных Cassandra}

Минимальным элементом данных в Cassandra является \textbf{столбец (column)}.
Столбец~-- это тройка следующих элементов: имя, значение, метка времени. Имя и значение являются произвольными массивами байт.
Пример столбца: (\textbf{имя}: <<email>>, \textbf{значение}: <<someEmail@example.com>>, \textbf{метка времени}: 1342323).
Метки времени играют роль ревизий. Если в столбец с одним именем два раза записали значение с разными метками времени, то останется
то, у которого метка времени больше. Например, если сначала была записана тройка (<<x>>,<<y>>,1), а затем~-- тройка (<<x>>,<<z>>,2), то
значением столбца с именем <<x>> будет <<z>>. При дальнейшем описании метки времени будут для нас не важны, поэтому мы часто будем 
под столбцом понимать пару (имя, значение).\\

Следующим элементом данных является \textbf{строка (row)}. \textbf{Строка}~-- это некоторый набор столбцов, имеющий ключ.
То есть, по некоторому ключу можно хранить произвольный набор колонок. Количество колонок в строке ограничено двумя миллиардами.
Особенностью организации колонок в строке является то, что колонки хранятся в отсортированном виде по имени. Способ сравнения ключей в сортировке 
можно выбирать. Например, можно считать имена колонок строками, и сравнивать их лексикографически.\\

Следующий элемент данных~-- это \textbf{семейство колонок (column family)}. Это неограниченный набор строк, имеющий имя.

Несколько семейств колонок объединяются в \textbf{пространство ключей (keyspace)}. И, наконец, несколько пространств ключей объединяются
в \textbf{кластер (cluster)}.

Таким образом, в Cassandra имеет место следующая иерархия данных: cluster -> keyspace -> column family -> row -> column.

\subsection{Структура базы данных Cassandra в проекте по управлению исследованиями}

Для хранения всех данных в проекте используется один кластер с названием <<OvercklockingCluster>> с одним пространством ключей
с названием <<OvercklockingKeyspace>>.

Были спроектированы способы хранения данных для двух случаев:
\begin{enumerate}
\item хранение больших объектов (например: файлы, картинки), представленных в виде массива байт (так называемые blob-ы)
\item хранение небольших объектов, которые можно описать в виде некоторых сущностей (например, объект <<пользователь>>)\\
\end{enumerate}

Рассмотрим способ хранения больших объектов. Для этого используется одно семейство колонок.
Каждый такой объект имеет уникальный id и хранится в строке с ключом, равным этому id.
Для того, чтобы записать объект в базу данных, проделывается следующая последовательность действий:
\begin{enumerate}
\begin{item}
Объект разбивается на небольшие части (например, по 1 мегабайту). 
Первой части соответствуют первые байты объекта, второй~-- следующие, и т.д.
\end{item}
\begin{item}
Каждая часть записывается в колонку с именем, равным ее номеру.
\end{item}
\begin{item}

В колонку с именем <<length>> записывается количество частей. Запись в эту колонку происходит строго после записи всех
остальных колонок.
\end{item}
\end{enumerate}
Данный способ хранения позволяет удобным образом впоследствии работать с объектом, а именно:
\begin{enumerate}
\begin{item}
Объект можно читать частично.
\end{item}
\begin{item}
По наличию или отсутствию колонки <<length>> можно понять, объект записан полностью или находится в процессе записи.
\end{item}
\begin{item}
Можно следить за прогрессом в записи/чтении объекта.\\
\end{item}
\end{enumerate}

Рассмотрим способ хранения небольших объектов-сущностей. 
Каждый такой объект имеет некоторый тип (тип <<пользователь>>, тип <<метаинформация>> и т.д.).
Также каждый объект имеет уникальный id.
Объект записывается в семейство колонок с именем, равным типу объекта в строку с ключом, равным id объекта.
Для записи объекта в базу данных выполняется следующая последовательность действий:
\begin{enumerate}
\item объект сериализуется в массив байт с помощью xml-сериалайзера
\item полученный массив байт записывается в качестве значения в колонку с именем <<XmlData>>
\end{enumerate}

\newpage
\section{Сервис импорта входных данных}

Мы рассмотрим сервис импорта на примере импорта файлов, поскольку для наших целей было необходимо импортировать именно файлы.
Сервис импорта представляет из себя консольное приложение, которое необходимо запускать при необходимости.
Приложению указывается путь к файлу, который необходимо импортировать. Сервис выполняет следующую последовательность действий:
\begin{enumerate}
\begin{item}
проверяет, не был ли файл с таким именем уже импортирован. Для этого поддерживается соглашение, что id файла в базе данных 
совпадает с именем файла в файловой системе. При наличии такого соглашения достаточно проверить существование объекта с заданным id.
\end{item}
\begin{item}
если файл еще не импортирован, то запускается процедура импорта. Она аналогична процедуре записи больших объектов, описанной в предыдущем пункте.
\end{item}
\begin{item}
в случае успешной процедуры импорта сервис записывает также метаинформацию о файле в виде отдельного объекта с тем же идентификатором.
Метаинформация включает в себя:
\begin{itemize}
\item имя файла
\item размер файла
\item тип файла (что по смыслу представляет из себя файл. Например: простой текст, строка ДНК)
\item тип содержимого файла (как файл хранится. на данный момент поддерживаются два типа: простой текст и архив GZip)\\
\end{itemize}
\end{item}
\end{enumerate}


\newpage
\section{Сервис запуска алгоритмов}

Данный сервис является центральным сервисом системы.
Он спроектирован в виде консольного приложения, который автоматически диагностирует появление новых входных данных
и запускает нужный алгоритм на этих данных.
Более подробно, сервис выполняет следующие действия:
\begin{enumerate}
\begin{item}
Смотрит в базе данных актуальный список возможных входных данных.
\end{item}
\begin{item}
Смотрит в базе данных актуальный список результатов алгоритма.
\end{item}
\begin{item}
Если находятся входные данные, для которых еще не построен результат, то 
на этих данных запускается алгоритм.
\end{item}
\begin{item}
Результат алгоритма записывается в базу данных. Тем самым одновременно происходит фиксация того, на каких
файлах алгоритм уже отработал.\\
\end{item}
\end{enumerate}

Архитектура сервиса имеет следующие особенности:
\begin{enumerate}
\begin{item}
Сервис однопоточный. Это позволяет избежать большинства трудностей в реализации и избавляет от труднодиагностируемых
ошибок в многопоточных сервисах.
\end{item}
\begin{item}
Для каждого типа алгоритмов может работать отдельный экземпляр сервиса. Это значит, что сервис обладает свойством масштабируемости.
\end{item}
\begin{item}
В текущей реализации не рекомендуется запускать более одного экземпляра сервиса для одного типа алгоритмов.
Поскольку в этом случае велика вероятность, что на одних и тех же данных алгоритм отработает несколько раз,
тем самым проделав лишнюю работу. Но при необходимости реализацию сервиса можно доработать таким образом, чтобы
параллельная обработка задач одного типа была возможна.
\end{item}
\begin{item}
Сервис зависит только от базы данных. Это очень сильно упрощает его разворачивание и администрирование, поскольку 
необходимо задать только настройку доступа к базе данных.\\
\end{item}
\end{enumerate}

В ходе эксплуатации сервиса появились некоторые потребности, которые планируется реализовать в следующей версии:
\begin{enumerate}
\begin{item}
Сервис должен уметь <<забывать>> результаты некоторых алгоритмов. Это полезно в ходе исследований,
когда периодически обнаруживаются ошибки/неточности в алгоритме и возникает потребность пересчитать результаты.
Сейчас это реализуется посредством удаления из базы данных соответствующих результатов.
\end{item}
\begin{item}
Сервис должен обладать свойством отказоустойчивости. В текущей реализации на один тип алгоритма необходимо запустить один сервис.
В случае, если он по какой-то причине перестанет работать, исследования будут приостановлены до тех пор, пока кто-то не перезапустит сервис.\\
\end{item}
\end{enumerate}

На рисунке ниже представлен скриншот сервиса в процессе его работы.

\begin{figure}

 \caption{Пример консоли сервиса в процессе работы}\label{fig1}

 \centering{

  \begin{picture}(200,100)

 \includegraphics[width=1\linewidth]{algorithmExecutor.jpg}

  \end{picture}

 }

\end{figure}

\newpage
\section{SQL-база данных для хранения статистической информации по результатам запуска алгоритмов}

Для анализа результатов алгоритмов, построения каких-то статистических выборок и другой аналитической работы база данных Cassandra 
является неподходящим решением, поскольку не предоставляет удобного инструмента сложных запросов.
Для этих целей хорошо подходят традиционные SQL-базы данных.
Поэтому было принято решение статистические результаты работы алгоритмов (а именно: время работы при заданном входе, численный размер результата и другие)
хранить в SQL-базе.

В качестве такой базы данных была выбрана широко известная база MySQL по следующим причинам:
\begin{enumerate}
\begin{item}
MySQL~-- бесплатная база данных. Поэтому практически любой хостинг ее поддерживает.
\end{item}
\begin{item}
Язык запросов MySQL достаточно функциональный и полностью удовлетворил нашим требованиям.
\end{item}
\end{enumerate}

\newpage
\section{Сервис импорта статистической информации в SQL-базу}

Сервис импорта представляет из себя веб-сервис с публичным API, имеющий несколько методов для 
загрузки новой информации по результатам алгоритма. Реализация сервиса как веб-сервиса с 
публичным API выла выбрана по следующим причине.Бесплатные хостинги имеют очень ограниченные ресурсы.
Это значит, что единственное, чем может пользоваться веб-сервис~-- это легковесная база данных.
Таким образом, все остальные сервисы системы управления исследованиями (прежде всего~-- база данных Cassandra
и сервис запуска алгоритмов) будут расположены физически очень сильно удаленно от веб-сервиса.
Значит, необходим интерфейс удаленного вызова. Веб-сервис с публичным API для этого очень хорошо подходит.

Сервис реализован на фреймворке \textbf{Spring MVC} поверх контейнера сервлетов \textbf{Apache Tomcat}.
Остановимся на этих инструментах подробнее.

\subsection{Контейнер сервлетов}

\textbf{Сервлет}~-- это Java-программа, выполняющаяся на стороне сервера и расширяющая функциональные возможности сервера. 
Сервлет взаимодействует с клиентами посредством принципа <<запрос>>-<<ответ>>.
Все сервлеты реализуют один интерфейс, определяющий методы жизненного цикла.

\textbf{Жизненный цикл сервлета}\\
Управлением сервлетами осуществляет специальная программа, которая называется \textbf{контейнер сервлетов}.
Жизненный цикл сервлета состоит из следующих шагов:
\begin{enumerate}
\item Если сервлет отсутствует в контейнере, то контейнер создает сервлет и вызывает специальный метод инициализации.
\item Если сервлет есть в контейнере, то он обрабатывает запрос в отдельном потоке.
\item Если контейнеру необходимо удалить сервлет, он вызывает специальный метод для разрушения сервлета.\\
\end{enumerate}

В качестве контейнера сервлетов был выбран \textbf{Apache Tomcat}.

\subsection{Паттерн Model-View-Controller}

Концепция \textbf{Model-View-Controller (MVC)} позволяет разделить данные, представление и обработку действий пользователя на три отдельных компонента:
\begin{itemize}
\begin{item}
\textbf{Модель (Model)}. Модель предоставляет знания: данные и методы работы с этими данными. Не содержит информации, как эти знания можно визуализировать.
\end{item}
\begin{item}
\textbf{Представление (View)}. Отвечает за представление данных. Или, другими словами~-- за визуализацию модели. Например, в качестве View может выступать
верстка веб-страницы.
\end{item}
\begin{item}
\textbf{Контроллер (Controller)}. Обеспечивает связь между моделью и представлением. Например, отвечает за обработку введенной пользователем информации и
использует Model и View для реализации необходимой реакции.
\end{item}
\end{itemize}
Важно отметить, что как представление, так и контроллер зависят от модели. 
Однако модель не зависит ни от представления, ни от контроллера. Тем самым достигается назначение такого разделения: 
оно позволяет строить модель независимо от визуального представления, а также создавать несколько различных представлений для одной модели.

Вся мощь паттерна MVC используется при реализации веб-сервиса. Сервис импорта от данного паттерна использует только контроллер.
Контроллер принимает извне информацию и сохраняет ее в базу данных.
Для реализации паттерна MVC был использован фреймворк \textbf{Spring MVC}.


\newpage
\section{Сервис экспорта статистической информации из NoSQL-базы данных в SQL-базу}

Сервис экспорта представляет из себя консольное приложение. 
Работа сервиса организована следующим образом:
\begin{enumerate}
\begin{item}
По расписанию проверят, не появилось ли в базе данных Cassandra новых результатов алгоритмов.
\end{item}
\begin{item}
Если появились новые, но еще не экспортированные данные, сервис посредством корректного запроса к 
API сервиса импорта в SQL-базу закачивает в нее эти данные.
\end{item}
\end{enumerate}

Архитектура сервиса обладает следующими особенностями:
\begin{enumerate}
\begin{item}
Параллельно может работать несколько независимых экземпляров сервиса. 
При этом может случиться так, что одна и та же информация будет экспортирована несколько раз.
Но экспорт отдельной сущности является быстрым действием, поэтому возможное выполнение такой работы несколько раз некритично.
\end{item}
\begin{item}
Сервис зависит только от базы данных Cassandra и от адреса для вызовов методов API сервиса импорта.
\end{item}
\end{enumerate}

\newpage
\section{Веб-сервис для отображения текущего состояния системы, а также построяния графиков по результатам работы}

Веб-сервис предоставляет пользователю следующую фукциональность:
\begin{enumerate}
\begin{item}
Аутентификация. Для работы в сервисе необходимо пройти процедуру аутентификации по логину и паролю.
\end{item}
\begin{item}
Просмотр информации про возможные входные данные алгоритмов (например, тип, размер).
\end{item}
\begin{item}
Просмотр результаты работы алгоритмов в виде таблицы результатов.
\end{item}
\begin{item}
Построение графиков по результатам работы алгоритмов.
\end{item}
\end{enumerate}

\subsection{Процедура аутентификации}

Опишем подробно, каким образом веб-сервис аутентифицирует пользователя и работает с механизмом сессий.
\begin{enumerate}
\begin{item}
Первая страница, которую видит неаутентифицированный пользователь~-- \textbf{страница логина}.
Данная страница содержит два поля ввода~-- по полю на логин и пароль, соответственно.
\end{item}
\begin{item}
После вводом пользователем логина и пароля данные посылаются на сервер.
Используя логин в качестве ключа, сервер находит в базе данных по данному логину информацию про пользователя.
\end{item}
\begin{item}
Если пользователя с таким логином не найдено, то сервер возвращает страницу логина с ошибкой аутентификации.
\end{item}
\begin{item}
Если пользователь с таким логином найден, то происходит сравнение паролей~-- хранимого в базе данных и пришедшего от
клиента.
Стоит заметить, что хранить в базе данных пароль в открытом виде небезопасно. В этом случае системный администратор
(или любой другой человек, имеющий доступ к базе данных) имеет возможность узнать пароль любого пользователя.
Поэтому в базе данных хранится \textbf{хеш от пароля}. При этом алгоритм хеширования выбирается таким образом, чтобы
восстановление данных по их хеш-коду было невозможной или очень сложной задачей. Более точно, следует выбирать 
\textbf{криптографические хеш-функции}. Одним из таких алгоритмов является алгоритм \textbf{MD5}.
Таким образом, при сравнении паролей сначала вычисляется значение хеш-функции пароля, введенного пользователем, после чего
полученное значение сравнивается с записью в базе данных.
\end{item}
\begin{item}
Если сравнение паролей дало отрицательный результат, то сервер возвращает страницу логина с ошибкой аутентификации.
\end{item}
\begin{item}
В случае положительного результата сравнения паролей сервер считает, что пользователь успешно прошел процедуру аутентификации.
Сервер выдаёт пользователю \textbf{сессию}. 
Физически это означает, что в памяти веб-сервиса по случайному уникальному идентификатору сохраняется объект, в котором
описаны параметры сессии~-- идентификатор пользователя и другая сопутствующая информация.
Также в cookies пользователя с именем <<SessionId>> сохраняется идентификатор сессии. 
После этого сервер перенаправляет пользователя на одну из страниц веб-сервиса.
\end{item}
\begin{item}
При каждом последующем запросе пользователя к серверу сервер проводит следующие действия:
\begin{enumerate}
\begin{item}
Если у пользователя выставлена кука <<SessionId>>, и в хранилище сессий есть с сессия 
с соответствующим идентификатором, то система считает, что пользователь аутентифицирован,
и возвращает ему ответ на его запрос.
\end{item}
\begin{item}
Если кука не выставлена, или сессия не найдена в хранилище сессий, то пользователь считается 
неаутентифицированным, и его перенаправляют на страницу логина, на которой он проходит процедуру аутентификации.
\end{item}
\end{enumerate}
\end{item}
\end{enumerate}

\chapter{Автоматизированный DI-контейнер}

При разработке больших сложных систем очень важную роль играет тестирование.
Очень удобно, если имеется достаточное количество автоматизированных тестов, поскольку
их можно запускать в автоматическом режиме, и почти мгновенно получать результат.
Чем лучше код покрыт тестами, тем проще находить ошибку: при правильном подходе ошибка
воспроизведется в небольшом простом тесте.

Однако далеко не каждую систему можно покрыть автоматизированными тестами.
Поэтому одна из основных тенденций в области программирования в последнее время – это проектирование архитектуры программных систем 
таким образом, чтобы их было легко тестировать.  
Чтобы дизайн кода удовлетворял этому требованию, необходимо придерживаться нескольких базовых принципов:
\begin{enumerate}
\item бить код на множество мелких классов, каждый из которых отвечает за небольшую часть функциональности: чем меньше класс, тем проще тестировать его поведение
\item тестировать класс сразу после его реализации или даже до реализации: чем раньше начать тестирование, тем проще понять, удобно ли построена архитектура
\item строить зависимости классов только от интерфейсов, а не от других классов: в этом случае в целях тестирования есть возможность подменять все модули, от которых зависит 
тестируемый класс, обеспечивая таким образом изолированное тестирование
\end{enumerate}
Последний из перечисленных принципов носит название dependency inversion principle, что дословно означает «принцип инверсии зависимостей»

Чтобы код удовлетворял этому принципу, следует придерживаться следующих правил:
\begin{enumerate}
\item у каждого класса должен быть интерфейс, который он реализует
\item все классы должны принимать все интерфейсы, от которы они зависят, в конструкторе
\end{enumerate}

Если следовать этим двум правилам, то возникает вопрос: в каком месте приложения будут создаваться необходимые классы?
Обычно создание всей иерархии классов выделяют в специальный класс-конфигуратор. При этом возникает проблема,
что в достаточно большой системе этот класс будет очень большим, а для его создания будет нужно провести ряд однотипных действий.
Кроме того, в процессе разработки этот класс будет постоянно меняться, а для его поддержки будет требоваться прилагать 
все больше и больше усилий.

Для автоматизации процесса конфигурирования были придуманы \textbf{dependency injection-контейнеры (DI-контейнеры)}.
Существует большое количество DI-контейнеров, и каждый из них обладает своими особенностями.
Мы рассмотрим две реализации DI-контейнеров для языка Java, после чего предложим альтернативный подход.

\section{BeanFactory~-- контейнер фреймворка Spring}
Рассмотрим один из самых распространенных контейнеров~-- BeanFactory.

Конфигурацие с помощью конструкторов. Пример конфигурирования: 
<bean id=<<\textbf{beanId}>> class=<<\textbf{beanClass}>>>\\
	<constructorArg [аттрибуты]>\\
</bean>\\
\textbf{BeanId}~-- с его помощью можно получить готовый экземпляр из BeanFactory, вызвав метод factory.getBean(beanId).
\textbf{BeanClass}~-- класс, экземпляр которого мы хотим получить.
Атрибуты в constructorArg (под аргументами подразумеваются аргументы конструктора):
\begin{enumerate}
\item value~-- значение, которое хотим передать в конструктор
\item type~-- тип аргумента, которому хотим установить требуемое значение
\item index~-- номер аргумента, которому хотим установить требуемое значение
\item name~-- имя аргумента, которому хотим установить требуемое значение
\item ref~-- id bean’а, который хотим подставить в качестве требуемого аргумента
\end{enumerate}

Таким образом, правила для разрешения всех зависимостей задаются с помощью xml-файла.\\

Большое количество конфигурирования в виде xml неудобно тем, что это очень слабо согласуется с кодом,
в результате чего вероятно большое количество ошибок, вызванных неправильной версией конфигурационного файла.

\section{Google Guice}
\textbf{Google Guice}, контейнер от компании Google, предлагает другой подход.
Для его конфигурирования необходимо проделать следующие вещи:

\begin{enumerate}
\item Пометить конструктор класса, который планируется создавать через контейнер, атрибутом @Inject
\item Для каждого интерфейса, который планируется получать через контейнер, указать класс, его реализующий.
\end{enumerate}

Таким образом, в контейнере guice ушли от конфигурирования посредством xml.
Это более удобный способ, поскольку всё конфигурирование описано прямо в коде, что позволяет следить за изменениями/обновлениями.
Между тем, данный способ обладает рядом недостатков:
\begin{enumerate}
\item Количество кода, необходимого для конфигурирования, мало отличается от способа без контейнера: всё равно необходимы 
большие классы~-- конфигураторы.
\item Использование атрибутов <<заражает>> весь код конкретной библиоткой контейнера.
Это значит, что впоследствии перейти на использование какого-то другого контейнера будет гораздо сложнее.\\
\end{enumerate}

Проанализировав недостатки описанных выше контейнеров, мы решили предложить другой подход

\section{Концепция автоматизированного DI-контейнера}

Заметим, что в программировании есть подход, который говорит о том, что иногда разумно использовать в коде
набор некоторых соглашений, вместо того чтобы сложным образом конфигурировать систему.
Вот небольшой список соглашений/тенденций, использование которых могло бы существенным образом упросить
конфигурирование системы:
\begin{enumerate}
\item у большинства интерфейсов системы ровно одна реализация
\item в большинстве случаев у классов ровно один публичный конструктор\\
\end{enumerate}

Если отталкиваться от этих двух простых правил, то можно реализовать \textbf{автоматизированный DI-контейнер}.
В основе концепции автоматизированного DI-контейнера лежат следующие принципы:
\begin{enumerate}
\item В большинстве случаев контейнер без всякой конфигурации может понять, какой класс необходимо 
использовать в качестве реализации интерфейса, поскольку в большинстве случаев реализация ровно одна.
\item В большинстве случаев контейнер без всякой конфигурации может понять, каким образом необходимо создавать объект,
поскольку у него ровно один публичный конструктор.
\end{enumerate}

Таким образом, объем кода/файлов для конфигурации может существенно сократиться, если следовать этим принципам.
На текущий момент полнофункциональный автоматизированный DI-контейнер еще не реализован, однако в код
системы по управлению исследованиями внедрено использование контейнера, который необходимо полностью конфигурировать.
Вся конфигурация выделена в отдельный модуль. После реализации автоматизированного DI-контейнера эту конфигурацию
можно будет либо существенно сократить, либо полностью удалить.

\backmatter %% Здесь заканчивается нумерованная часть документа и начинаютяс заключение и ссылки

\Conclusion % заключение к отчёту
В результате НИР была проделана следующая работа:
\begin{enumerate}
\item полностью реализована и внедрена система по управлению исследованиями,
позволившая автоматизировать процесс анализа работы трудоемких алгоритмов
\item разработана концепция автоматизированного DI-контейнера
\end{enumerate}

Результаты НИР являются успешными, поскольку уже сейчас видно существенное упрощение 
процесса сбора статистики о работе исследуемых алгоритмов.
Однако уже сейчас видно, каким образом текущие результаты можно улучшить и вывести разработанную систему на другой уровень.

%\begin{thebibliography}{1} %% здесь библиографический список

%\bibitem{filosofyNewestdict}

%{Грицанов} А.А.~и др.

%\newblock {\em Новейший философский словарь}.

%\newblock Мн.: Книжный Дом., 2003.

%\end{thebibliography}

% \bibliography{biblio/filosofy} %% вместо вставки библиографии можно использовать базы BiBTeX - просто раскомментируйте эту строку.

\end{document}
