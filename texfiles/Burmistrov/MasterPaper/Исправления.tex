\documentclass[12pt]{article}
\usepackage{extsizes}
\usepackage[cp1251]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{indentfirst}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{graphicx}

%\usepackage{rusnotation}
\usepackage{srcltx}

\usepackage[left=3cm, right=2cm, top=20mm, bottom=25mm]{geometry}
\pagestyle{plain}
\baselineskip=1.5\baselineskip

\renewcommand{\leq}{\leqslant}
\renewcommand{\geq}{\geqslant}
\newcommand{\R}{\mathbb{R}}
\newcommand{\aB}{\hat{a}_B}
\newcommand{\strset}{\texttt{set}}
\newcommand{\rootset}{\texttt{rooted\_set}}

\newtheorem{teo}{Теорема}
\newtheorem{pro}{Предложение}
\newtheorem{lem}{Лемма}
\newtheorem{cons}{Следствие}
%\newtheorem{algo}{Алгоритм}
%\newtheorem*{exa}{Пример}

\theoremstyle{definition}
\newtheorem{algo}{Алгоритм}
\newtheorem*{exa}{Пример}

\tolerance=1000

\begin{document}
\begin{enumerate}

\begin{item}
Введение.
\begin{itemize}
\item Использую термин "алгоритмы эффективного ввода-вывода"  вместо $I/O-Efficient$-алгоритмы.
\item Исправлена опечатка в предложении "... благодаря связи с алгоритмом Лемпеля-Зива, широко применИмом на практике": исправил на "применяемом".
\end{itemize}
\end{item}

\begin{item}
Обозначения.
\begin{itemize}
\item Переименовал пункт в "Обозначения и определения".
\item Дал в этом пункте определение суффикса и его номера.
\item Дал определение строк Фибоначчи.
\end{itemize}
\end{item}

\begin{item}
LZ77-факторизация.

\begin{enumerate}
\begin{item}
Факторизация суффиксным деревом.
\begin{itemize}
\item Перед этим пунктом было начатое, но не законченное предложение -- убрал.
\item Добавил пункт 3.1~-- "Определение и основные свойства суффиксного дерева". Дал простое (как мне кажется) 
определение суффиксного дерева, привел картинку в качестве примера.
\item Исправил недочет в шагах 1 и 4 описания алгоритма факторизации.
\item Исправил пункт 2 описания алгоритма факторизации, теперь сложность этого пункта прозрачна.
\end{itemize}
\end{item}

\begin{item}
Факторизация суффиксным массивом.
\begin{itemize}
\item Убрал определение номера фактора из этого пункта, так как оно уже есть в пункте 2.
\item Исправил опечатку в слове "отсортированный".
\item Исправил опечатку в Лемме 2 в слове "аргументу".
\item Переименовал Sparse Table в "разреженную таблицу".
\item В разделе 3.2.2 оставил допущение, что $n=2^k$. Мне кажется, так проще вводить, что такое $k$.
\item В разделе 3.2.2 исправил $A[i][0]$ на $A[i]$.
\item В разделе 3.2.4 в пункте 1 убрал неточность с тем, что такое $i$.
\item Раздел 3.2.4, вывод. 
Исправил формулировку, теперь везде говорю, что второй алгоритм факторизации
лучше тем, что проще переносится на случай внешней памяти.

Но я не очень согласен с замечанием, что он должен сильно проигрывать суффиксному дереву в оперативной памяти.
Во-первых, большая константа только у алгоритма построения суффиксного массива. У алгоритма построения $LCP$ константа
очень мала (по-моему, она близка к 1), я в этом много раз убеждался. 
Но у суффиксного дерева константа тоже большая.
Из АСМ-овского прошлого я помню, что даже $n\log{n}$-ый вариант построения суффиксного массива зачастую работал примерно столько же, 
сколько алгоритм Укконена (в силу того, что в суффиксном дереве сложно эффективно хранить ссылки в узлах). 
А линейный алгоритм суфф. массива немного лучше, чем $n\log{n}$-ый.\\

Да, я согласен, что без статистики заявлять такие вещи неправильно, поэтому убрал. К тому же, действительно, присутствует логарифмическая 
константа.\\
\end{itemize}
\end{item}
\end{enumerate}

\end{item}

\begin{item}
ПП как сжатое представление строк.

\begin{itemize}
\item В разделе 4.1 сдела пример более изящным и дал прозрачное определение размеру ПП.
\item В разделе 4.2 сделал перенос слова "сбалансированной".
\item В разделе 4.2.1 исправил ошибки в рисунке и отмеченные опечатки.
\item В разделе 4.2.2 исправил отмеченные опечатки.
\item В разделе 4.3 исправил отмеченные опечатки и неточности в формулировках.
\item В разделе 4.3 исправил ошибку в 1 пункте шага алгоритма.
\item Раздел 4.3, пример. Переформулировал пример так, чтобы не возникало вопроса о корректности высказанной мысли.
\item В разделе 4.4. исправил опечатки в слове "перебалансировок" (2 абзац), "классического" (абзац перед Теоремой 2) и в формулировке
Теоремы 2.
\item В разделе 4.4. добавил примечание о том, что размер $r$ может быть большим.
\end{itemize}

\end{item}

\begin{item}
Практические результаты.

\begin{itemize}
\item Ответ на вопрос про корпус текстов: мы считали, что нужно проверять алгоритмы на тех данных, на которых 
они будут иметь хороший коэффициент сжатия. Мы считали, что 4-буквенные ДНК~-- подходящий для этого набор строк.
Алфавит небольшой, а строки реально используются в жизни.
\item Убрал упоминание про $LZW$. Кажется, он там был лишним, вызывал только вопросы.
\item Термин "степень сжатия" заменил на "относительный размер" и объяснил, что нас интересуют зависимости количества факторов и размера ПП
от длины входной строки, а классическая степень сжатия не интересует.
\item Исправил ошибки ни рисунках 4 и 7 (сейчас они имеют номера 5 и 8).
\end{itemize}

\end{item}

\begin{item}
Заключение.

Исправил отмеченную опечатку.
\end{item}

\begin{item}
Список литературы.

Отсортировал по фамилиям.
\end{item}
\end{enumerate}

\end{document}