\subsection{Возможности конфигурации контейнера}

\subsubsection{Внутреннее устройство конфигурирования}

Для достижения гибкости контейнера необходимо тщательно продумать внутренний механизм конфигурирования и его реализацию. При этом механизм должен быть достаточно гибким:
он не должен быть жестко завязан на имеющихся типах конфигурирования, наоборот, он должен быть открытым для новых. Отсюда появилась идея интерфейса IConfiguration.
Каждая абстракция, которая рассматривается контейнером, имеет свою конфигурацию "--- информацию о том, как должен собираться соответствующий объект, если контейнеру требуется его создать.
Вся эта информация содержится в классе, реализующем интерфейс IConfiguration. Он имеет три метода, таких же, как и методы-запросы у самого контейнера: get, create и getAll.
В данный момент метод getAll ведет себя одинаково у всех реализаций: он получит все реализации данной абстракции из расширенного графа наследования, 
сделает для каждой из реализаций запрос на получение экземпляров и вернет все эти объекты в одном массиве в качестве результата.
Существенные отличия будут в алгоритмах работы методов get и create.
Манипулирование объектами-конфигурациями производится с помощью интерфейса IConfigurationsManager.
Запрос к контейнеру делегируется соответствующему объекту IConfiguration, который обеспечивает поведение, предписанное пользователем.

Для описания работы реализаций этого интерфейса нам понадобятся несколько определений.

\itshapeРазрешение абстракции в класс \upshape"--- это выбор единственного ребенка данной абстракции в расширенном графе наследования. Если он не единственный "--- считается, что разрешение
невозможно и вызывается исключение.

\itshapeКонструирование объекта (экземпляра) \upshape"--- это создание экземпляра определенного класса. Более подробно данный процесс будет рассмотрен в следующей части.

По умолчанию в качестве конфигурации у каждой абстракции выставлена AutoConfiguration. 

Ответ на запрос create при данной конфигурации будет получен с помощью следующего алгоритма:

\begin{enumerate}
	\item Разрешение абстракции в класс
	\item Сборка экземпляра полученного класса, который и будет возвращен в качестве результата
\end{enumerate}


Результат запроса get при конфигурации по умолчанию будет получен с помощью следующего алгоритма:

\begin{enumerate}
	\item Если запрос на получение экземпляра данной абстракции уже был когда-либо выполнен, то вернуть в качестве результата ответ на тот запрос
	\item Разрешение абстракции в класс
	\item Если абстракция была разрешена сама в себя (это значит, что абстракция сама является классом), то произойдет сборка экземпляра и он вернется в качестве результата
	\item В противном случае будет сделан перевызов метода get у конфигурации, соответствующей классу, в который была разрешена эта абстракция
\end{enumerate}


\subsubsection{Привязка конкретной реализации к абстракции}

Если абстракция имеет множество реализаций, то без дополнительной конфигурации контейнер не сможет принять решение, экземпляр какого класса возвращать.

\begin{solution}
	Расширить интерфейс контейнера, добавив в него метод bindImplementation, позволяющий привязывать к конкретной абстракции конкретную реализацию, 
	экземпляр которой требуется впоследствии получать из контейнера.
\end{solution}

Метод имеет два аргумента. Вызов  метода bindImplementation с аргументами abstraction и implementation привяжет к абстракции abstracion ее реализацию implementation,
подменив текущую конфигурацию этой абстракции на конфигурацию с привязанной реализацией.
Результаты запросов get и create при данной конфигурации будут получены с помощью делегирования этих запросов конфигурации, привязанной к указанной реализации.

\subsubsection{Привязка конкретного экземпляра к абстракции}

Бывают ситуации, в которых требуется получать из контейнера в качестве ответа на запрос на получение один и тот же объект, созданный вне контейнера.

\begin{solution}
	Расширить интерфейс контейнера, добавив в него метод bindInstance, позволяющий привязывать к конкретной абстракции конкретный экземпляр одного из ее наследников.
\end{solution}
Метод имеет два аргумента, первый имеет тип Class, второй "--- Object. Вызов bindInstance(abstraction, instance) привяжет к абстракции abstraction объект instance, 
подменив текущую конфигурацию этой абстракции на конфигурацию с привязанным экземпляром. 
При этой конфигурации запрос на создание будет обрабатываться тем же образом, что и при конфигурации по умолчанию, 
а при запросе на получение будет возвращаться всегда объект instance.