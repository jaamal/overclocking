\subsection{Загрузка классов}

В, Java перед тем как использовать класс, необходимо загрузить его в JVM.
В этой части будет рассмотрен вопрос получения класса по его байткоду и его загрузки.

Байткод "--- последовательность байт, получаемая в результате компилирования исходного кода класса.

\begin{problem}
Реализовать механизм, позволяющий прочитать файл с байткодом и получить объект типа Class, чтобы потом с помощью этого объекта создавать экземпляры соответствующего класса.
\end{problem}
Поверхностное исследование дает следующий результат: в языке Java существует механизм загрузки классов, реализованный как абстрактный класс ClassLoader, наследники которого могут
загружать классы. Среди методов данного класса есть protected-метод defineClass, который позволяет получить объект типа Class по массиву байтов, а также метод loadClass, который 
загружает класс по его имени. Используя эти знания, можно сформулировать следующее

\begin{solution}
	Реализовать собственного наследника класса ClassLoader, в котором можно получить Class по байткоду и совершить его загрузку с помощью системного загрузчика
	(системный загрузчик классов может быть получен с помощью вызова ClassLoader.getSystemClassLoader()).
\end{solution}

Это решение действительно работает в некоторых случаях. Например, модульное тестирование кода не выявило никаких проблем. Некорректность данного подхода выявилась при попытке 
внедрить контейнер в веб-сервис: были обнаружены классы, которые требовали загрузку несистемым загрузчиком классов.

Более глубокое исследование механизма загрузки классов показало, что загрузка классов производится далеко не всегда с помощью системного загрузчика классов. Например, если нам требуется
загрузить класс с некоторого удаленного источника, потребуется реализация загрузчика, который будет делать запрос по сети на некий сторонний сервис, с которого в качестве 
результата на этот запрос вернется нужный объект типа Class. Такие загрузчики могут ипользоваться, в частности, в клиент-серверных архитектурах.

Получается, что нельзя загружать все классы системным загрузчиком, потому что среди них может оказаться класс, который не сможет быть им загружен.
И возникает новая 
\begin{problem}
Научиться определять, каким именно загрузчиком должен быть загружен данный класс.
\end{problem}

В язык Java встроен достаточно удобный механизм для профилирования и прочих смежных задач "--- Instrumentation. Данный интерфейс помимо прочих имеет метод getAllLoadedClasses, 
возвращающий список всех классов, которые подгружены JVM на момент вызова метода. У объекта типа Class есть метод getClassLoader, который вернет загрузчика данного класса.
Получаем

\begin{solution}
	В момент инициализации контейнера получить список всех загруженных классов, после чего получить список всех ClassLoader'ов, использовавшихся для загрузки, 
	и после этого, при необходимости загрузить класс, сначала проверить, не загружен ли он, и если он не загружен, то попытаться произвести загрузку одним из уже известных загрузчиков.
\end{solution}

Однако и это решение нам не подходит: если экземпляр контейнера является статическим полем и инициализируется во время загрузки класса, то возможна следующая ситуация:
класс, в котором лежит контейнер, загружается не последним, метод getAllLoadedClasses вернет только уже загруженные классы, среди которых может не оказаться ни одного класса, который
должен быть загружен некоторым ClassLoader'ом, и мы о нем просто ничего не узнаем.

Данные выводы подводят к следующему утверждению: \itshape в момент инициализации контейнера невозможно узнать полный список всех загрузчиков классов, 
которые будут использованы во время работы приложения\upshape. Отсюда вытекает

\begin{problem}
Реализовать механизм, позволяющий сообщать контейнеру о загрузчиках конкретных классов.
\end{problem}

Понятно, что конфигурирование загрузчиков для каждого класса породит
огромное количество кода, что противоречит нашему стремлению минимизировать код конфигурирования контейнера. Однако можно воспользоваться следующим соображением:
\itshapeбольшинство классов загружаются тем же загрузчиком, что и интерфейс, который он реализует\upshape. Мы всегда можем узнать загрузчик любого аргумента конструктора любого класса и
загрузчик аргумента запроса на получение объекта к контейнеру с помощью метода getClassLoader().
Таким образом, получаем
\begin{solution}
	Расширить интерфейс контейнера, добавив в него метод, позволяющий привязывать к конкретному классу конкретный загрузчик, которым его необходимо грузить.
\end{solution}
Это решение сохраняет минималистичность конфигурации при выполнении вышеуказанного соображения, так как в этом случае классов, для которых нужно явно указать загрузчика, будет
достаточно мало.