\subsection{Spring IoC container}

Spring Framework "--- один из самых широко распространенных фреймворков среди Java-разработчиков. Его можно рассматривать как коллекцию меньших фреймворков, каждый из которых
может работать по отдельности. Одна из компонент Spring "--- это IoC контейнер.

\subsubsection{Способы конфигурирования}

Spring IoC Container "--- контейнер, конфигурирование которого производится в основном с использованием XML-файлов. Создать контейнер можно следующим образом:

\begin{lstlisting}[language=Java,caption={Создание контейнера}]
ApplicationContext applicationContext = new ClassPathXmlApplicationContext(new String[]{"beans.xml"});
\end{lstlisting}

Здесь <<beans.xml>> "--- XML-файл, в котором описана конфигурация контейнера.

В файле с конфигурацией необходимо описать все объекты, которые нужно будет впоследствии получать из контейнера. Для описания объекта создается XML-элемент <bean>, 
в атрибутах которого надо указать id "--- идентификатор объекта и class "--- полное имя класса, экземпляром которого этот объект будет являться. Внутри элемента можно указать, 
какие значения в какие поля подставить при построении данного объекта. Например, если есть класс Sample с конструктором, принимающим на вход два аргумента String и int, 
и из контейнера хочется получить экземпляр этого класса с подстановкой в качестве аргумента строки <<Just sample>> и числа 146, нужно создать следующий элемент:

\begin{lstlisting}[language=XML,caption={Пример конфигурации объекта}]
<bean id="SampleClassImpl" class="Sample">
	<constructor-arg type="int" value="146" />
	<constructor-arg type="java.lang.String" value="Just sample" />
</bean>
\end{lstlisting}

В элементе <constructor-arg> необходимо указать, в какой именно аргумент будет производиться подстановка и значение, которое нужно подставить.
Аргумент можно указать с помощью следующих атрибутов:
\begin{itemize}
	\item type – тип аргумента конструктора
	\item index – номер аргумента конструктора
	\item name – имя аргумента конструктора
\end{itemize}

Подставляемое значение указывается одним из двух способов:
\begin{itemize}
	\item value – значение, которое хотим передать в качестве аргумента конструктору
	\item ref – идентификатор объекта, который хотим подставить в качестве аргумента (объект с этим идентификатором также должен быть описан в конфигурационном файле)
\end{itemize}

Если в файле с конфигурацией есть описание лишь одного объекта, имеющего заданный тип, и нужно подставить этот объект в некоторое поле в другом объекте, то можно воспользоваться 
аннотацией @Autowired. Если поле помечено этой аннотацией, то контейнер сам найдет объект, который нужно подставить. Также этой аннотацией можно пометить конструктор, тогда в 
качестве аргументов в конструктор будут передаваться те элементы, которые найдет контейнер. 

Если поле помечено @Autowired, но при этом есть несколько описаний объектов одного и того же типа "--- будет вызвано исключение. 
Но если при этом @Autowired помечен массив объектов, то контейнер подставит в это поле все объекты, которые указаны в конфигурации и подходят под данный тип. 
Для того, чтобы воспользоваться этой аннотацией, необходимо в XML-файле добавить тэг <context:annotation-config />

Основные моменты реализации описанного в начале примера выглядит следующим образом:

\begin{lstlisting}[language=XML,caption={Файл конфигурации (без стандартных заголовков)}]
<context:annotation-config/>
<bean id="gmail" class="GmailAuthenticator"/>
<bean id="facebook" class="FacebookAuthenticator"/>
<bean id="local" class="LocalAuthenticator"/>
<bean id="authenticatorsProvider" class="AuthenticatorsProvider"/>
\end{lstlisting}

\begin{lstlisting}[language=Java,caption={Конструктор класса AuthenticatorsProvider}]
@Autowired
public AuthenticatorsProvider(IAuthenticator[] authenticators)
{
	this.authenticators = authenticators;
}
\end{lstlisting}

\begin{lstlisting}[language=Java,caption={Место получения экземпляра}]
IAuthenticatorsProvider provider = (IAuthenticatorsProvider)applicationContext.getBean("authenticatorsProvider");
\end{lstlisting}

\subsubsection{Плюсы и минусы}

Основной плюс данного контейнера "--- это его гибкость. Богатый набор способов конфигурации объектов позволяет собрать практически любой экземпляр, который может понадобиться.
Однако, есть ряд недостатков.

Метод getBean у ApplicationContext всегда возвращает Object, то есть контейнер не является <<type safe>>, и каждый раз, когда мы делаем запрос на получение объекта, нам нужно
явно приводить полученный объект к нужному типу.

Если появится новый механизм аутентификации "--- придется править конфигурационный файл: добавлять новый элемент конфигурации.

Как видно, почти вся информация о конфигурации должна содержаться в конфигурационном XML-файле (как минимум, там нужно описать все объекты, которые могут понадобиться).
Понятно, что его размер прямо пропорционален размеру проекта, в который происходит внедрение контейнера, соответственно <<с нуля>> внедрить его в огромный проект достаточно трудно.