\subsection{Инициализация контейнера}

Инициализация контейнера заключается в просмотре некоторого множества байткодов классов и составлении графа наследования между этими классами.

\subsubsection{Просмотр байткодов}
Для начала требуется определиться с тем, экземпляры каких именно классов будем получать из контейнера и где лежат соответствующие им байткоды.
Иногда будет достаточно просто просмотреть содержимое папок, перечисленных в свойстве <<java.class.path>>, но бывают случаи, когда этого недостаточно. Например, если речь идет о
веб-сервисе, то скорее всего это свойство просто не определено, и в таких случаях очень часто невозможно понять по переменным среды откуда берутся классы, из-за чего придется
вручную сообщить контейнеру о всех папках, в которых следует искать требуемые файлы.
Также следует указать контейнеру, какие jar-файлы следует обрабатывать, а какие нет. 
Всю эту информацию контейнер может принять в конструктор в виде реализации интерфейса IClassPathScannerConfiguration.
Он имеет два метода:
\begin{itemize}
	\item getClassPaths "--- метод должен возвращать список всех папок, в которых следует искать байткоды
	\item acceptsJar "--- метод принимает в качестве единственного аргумента имя jar-файла, 
				и должен вернуть true, если требуется просмотреть его содержимое и найти там байткоды, или false в противном случае
	
\end{itemize}

Если создавать контейнер с использованием пустого конструктора, то будет использоваться реализация интерфейса, которая возвращает значение свойства java.class.path в качестве
списка папок для просмотра, и не просматривает никакие jar-файлы.

Просмотр папок производится с помощью поиска в глубину по дереву директорий. При анализе очередного элемента папки возможны 4 варианта типа элемента и соответствующих действий:
\begin{itemize}
	\item папка "--- рекурсивно запустить поиск в глубину из этой папки
	\item class-файл "--- прочитать байткод из файла, преобразовать его в объект, содержащий информацию о внутреннем устройстве класса, и сохранить его в память
	\item jar-файл "--- с помощью метода acceptsJar принять решение, читать этот файл или нет, и в случае положительного решения запустить поиск байткодов по элементам jar-файла
	\item любой другой файл "--- ничего не делать
\end{itemize}

Для преобразования байткода используется библиотека BCEL (Byte Code Engineering Library) \cite{bcel}, которая позволяет прочитать байткод из файла и преобразовать его в объект типа JavaClass, 
из которого в свою очередь достаточно удобно брать информацию об устройстве класса.

\subsubsection{Построение графа реализации}
Теперь стоит задача "--- построить структуру данных, которая позволит эффективно узнавать список всех реализаций конкретной абстракции.
Здесь под абстракцией понимается интерфейс, абстрактный класс или неабстрактный класс, под классом же понимается исключительно неабстрактный класс.

При сохранении в память строится ориентированный граф прямой реализации между абстракциями по следующему правилу: из абстракции А в абстракцию В идет ребро тогда и только тогда, 
когда абстракция А является либо непосредственным предком абстракции В, либо интерфейсом, который абстракция В непосредственно реализует.

После того, как все папки просмотрены, все классы перечислены и на них построен граф прямой реализации, строится расширенный граф реализации, 
с помощью которого впоследствии контейнер будет принимать решение о том, экземпляр какого именно класса следует вернуть в качестве результата запроса. 
Его можно определить следующим образом: из абстракции А в абстракцию В идет ребро тогда и только тогда, когда В является неабстрактным классом,
и при этом существует некоторый путь из абстракции А в абстракцию В в графе прямой реализации. 
Расширенный граф реализаций строится для того, чтобы можно было достаточно быстро получать список реализаций абстракции. Это делается с использованием одного запроса get к 
встроенному в язык Java HashMap'у, который в среднем работает за O(1).


Покажем, как должны выглядеть вышеописанные графы на примере, описанном в главе 2:


\begin{center}
	$\xymatrix{
	\\
	Main & & IAuthenticatorsProvider \ar@{->}[d] \\
	 & & AuthenticatorsProvider \\
	 & IAuthenticator \ar@{->}[d] \ar@{->}[dl] \ar@{->}[dr]& \\
	LocalAuthenticator & GmailAuthenticator & FacebookAuthenticator \\
	 & & & 
	}$
\end{center}
\begin{center}
Рисунок 1. Граф прямой реализации
\end{center}

\begin{center}
 $\xymatrix{
\\
Main \ar@(dl,dr)[] & & IAuthenticatorsProvider \ar@{->}[d] \\
 & & AuthenticatorsProvider \ar@(dl,dr)[]  \\
 & IAuthenticator \ar@{->}[d] \ar@{->}[dl] \ar@{->}[dr]& \\
LocalAuthenticator \ar@(dl,dr)[]  & GmailAuthenticator \ar@(dl,dr)[]  & FacebookAuthenticator \ar@(dl,dr)[] \\
& & &
 }$
\end{center}

\begin{center}
Рисунок 2. Расширенный граф реализации
\end{center}