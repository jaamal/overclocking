\section{Введение}

При разработке достаточно больших по объему кода сервисов на объектно-ориентированных языках программирования желательно придерживаться пяти основных принципов дизайна
классов "--- SOLID:

\begin{enumerate}
	\item Single responsibility principle "--- на класс должна быть возложена лишь одна ответственность
	\item Open-closed principle "--- класс должен иметь возможность расширения функциональности без изменения имеющейся
	\item Liskov substitution principle "--- наследник должен уметь заменять свой базовый класс без изменения поведения
	\item Interface segregation principle "--- универсальные интерфейсы следует разделять на более специализированные
	\item Dependency inversion principle "--- зависимости следует выстраивать между абстракциями и не следует между реализациями
\end{enumerate}

Соблюдение последнего принципа подразумевает, что использование оператора создания объекта недопустимо в коде реализации модуля (если это не фабрика). Из этого следует, что все зависимости нужно
принимать в конструктор. Получается, что в коде приложения должна быть некоторая точка старта, в которой создаются все используемые объекты. В достаточно больших проектах точка старта 
будет иметь внушительный объем, из-за чего она будет трудноподдерживаема. 

Одним из решений данной проблемы является использование Dependency Injection (или Inversion of Control) контейнеров.
Контейнер берет на себя ответственность за создание объектов и разрешение зависимостей. Существует достаточно много реализаций DI-контейнеров для языка Java. 
В параграфе 1 рассмотрены два из числа наиболее используемых контейнера, выделен их главный недостаток "--- большой объем конфигурационного кода: контейнеры
требуют от разработчика тем или иным способом перечислить все классы, экземпляры которых потребуется получать или создавать.

Была поставлена цель "--- реализовать DI-контейнер, который не потребует большого количества конфигурационного кода.

Цель достигнута: в параграфе 2 описан контейнер, отличительной особенностью которого является отсутствие необходимости перечислять все классы, используемые
приложением при его конфигурировании. Имеется опыт внедрения контейнера в веб-сервис. Исходный код и собранная библиотека доступны со страницы проекта https://code.google.com/p/jrobo-container .